



# Django 

## django 文件上传

```python
def upload(request):
	if request.method == 'GET':
		return render(request,'upload.html')
	elif request.method == 'POST':
		content =request.FILES.get("upload", None)
		if not content:
			return HttpResponse("没有上传内容")
		position = os.path.join('C:\\Users\\huyuan\\Desktop\\test\\upload',content.name)
		#获取上传文件的文件名，并将其存储到指定位置
 
		storage = open(position,'wb+')       #打开存储文件
		for chunk in content.chunks():       #分块写入文件
			storage.write(chunk)
		storage.close()                      #写入完成后关闭文件
		return HttpResponse("上传成功")      #返回客户端信息
	else:
		return HttpResponseRedirect("不支持的请求方法")
```

> 说明：

上传文件的常用方法和属性：

-   content.read()：从文件中读取整个上传的数据，这个方法只适合小文件
-   content.chunks()：按块写入文件，通过for循环可以将大文件按块写入到磁盘中
-   content.name：获取文件名，包括后缀
-   content.size：获取文件大小

## orm 中 FileField 自定义上传目录和文件名

```python
file = models.FileField(verbose_name='本地存储目录', null=True, blank=True,upload_to=directory_path)
```

```python
def directory_path(instance, filename):
    # file will be uploaded to MEDIA_ROOT/
    uid = str(uuid.uuid4())
    date = time.strftime("%Y-%m-%d", time.localtime())
    upload_to = "{}/{}/{}".format(date, uid, filename)
    return upload_to
```

## 文件预览 

#### **访问上传的图片**

假设用户上传了一个图片：a.jpg
如果settings.py中设置了**MEDIA_URL="/media/"**，访问时应该写的路径为：**/media/avatar/a.jpg**

要想在前端页面直接访问用户上传的文件，还需要配置一条url，urls.py添加如下:

```
# 必须先导入如下模块
from django.views.static import serve
from myblog import settings
urlpatterns = [
    #... 省略部分配置 ...
    # 添加media 配置
    url(r'^media/(?P<path>.*)$', serve, {'document_root': settings.MEDIA_ROOT}),
]
```

## pip 安装报错问题

> Command “/usr/bin/python -u -c “import setuptools, tokenize;file=’/tmp/pip-install-uqbRn0/uwsgi/setup.py’;f=getattr(tokenize, ‘open’, open)(file);code=f.read().replace(’\r\n’, ‘\n’);f.close();exec(compile(code, file, ‘exec’))” install --record /tmp/pip-record-C6Qm8w/install-record.txt --single-version-externally-managed --compile” failed with error code 1 in /tmp/pip-install-uqbRn0/uwsgi/

解决方法
1、首先将pip更新到最新版本

[root@localhost ~]# python -m pip install --upgrade pip
1
2、安装依赖包(主要依赖问题)

[root@localhost ~]# yum -y install python-devel libevent-devel libjpeg-devel

#在centos8.0中，python版本是3.6的，这时需要安装 
[root@localhost ~]# yum -y install python3-devel libevent-devel libjpeg-devel

## celery定时任务常见场景

[(https://www.cnblogs.com/weiweivip666/p/13751867.html#定时任务常见场景)

```
1.订单超时
2.生日邮件[例如,每天凌晨检查当天有没有用户生日,有则发送一份祝福邮件]
3.财务统计[例如,每个月的1号,把当月的订单进行统计,生成一个财务记录，保存到数据库中]
4.页面缓存[列如,把首页设置为每隔5分钟生成一次缓存]
```

***2\***|***0\*****使用celery的定时任务来完成订单超时功能**

在实现定时任务之前,我们需要先简单使用以下
我们需要新增一个任务目录,例如order



```shell
celey_tasks/
    ├── sms/
    │   ├── __init__.py
    │   └── tasks.py
    ├── config.py
    ├── __init__.py
    ├── main.py
    ├── order/
    │   ├── __init__.py
    │   └── tasks.py
    └── sms
```

在main.py中，注册任务目录[注意,接下来后面我们使用django的模型处理,所以必须对django的配置进行引入]



```python
import os
from celery import Celery
# 1.创建示例对象
app = Celery('luffy')
# 2.加载配置
app.config_from_object('celery_tasks.config')
# 3.注册任务[自动搜索并加载任务]
# 参数必须必须是一个列表,里面每一个任务都是任务的路径名称
# app.autodiscover_tasks(['任务1','任务2'])
app.autodiscover_tasks(['celery_tasks.sms','celery_tasks.order'])
# 4.在终端下面运行celery命令启动celery
# celery -A 主程序 worker --loglevel=info
# celery -A celery_tasks.main worker --loglevel=info
```

接下来，在order任务目录下，创建固定名字的任务文件taks.py，代码



```python
from order.models import Order
from mycelery.main import app
from datetime import datetime, timedelta
from luffyapi.settings import contants

@app.task(name='check_oo') #起别名,如果起了别名,那么config中调度任务写别名就行
def check_order():
    """订单超时取消任务"""
    # 超时条件,当前时间 > 订单生成时间+超时时间 = 超时了
    # 当前时间 - 超时时间段 > 订单生成时间 = 超时了
    now_time = datetime.now() #当前时间
    out_time = contants.ORDER_OUTTIME # 配置文件中设置的超时时间
    # 超时时间点
    order_out_time = now_time - timedelta(seconds=out_time)

    order_list = Order.objects.filter(order_status=0, created_time__lt=order_out_time)
    for order in order_list:
        order.order_status = 3
        order.save()
```

接下来，我们需要把这个任务设置定时任务，所以需要借助celery本身提供的Crontab模块
在配置文件config.py中，对定时任务进行注册



```python
# 任务队列的链接地址
broker_url = 'redis://127.0.0.1:6379/15'
# 结果队列的链接地址
result_backend = 'redis://127.0.0.1:6379/14'

from celery.schedules import crontab
from .main import app
# 和django框架同步时区
from django.conf import settings
app.conf.timezone = settings.TIME_ZONE
# 定时任务的调度列表，用于注册定时任务
app.conf.beat_schedule = {
      'check_order_outtime':{ #任务名称随便起
            # 本地调度的任务
            'task': 'check_order'，# 这里的任务名称必须先到main.py中注册,如果写了别名,直接写别名就可以了,没有写别名,需要用路径写法order.tasks.check_order
            # 定时任务的调度周期
            #'schedule': crontab(minute=0, hour=0),# 每周凌晨00:00
            'schedule': crontab(), #每分钟,没写秒数,那么就是每分钟的0秒开始
            # 'args': (16, 16)#注意：任务就是一个函数,所有如果有参数则需要传递
            # 'kwargs' 有名参数
      }
}
```

接下来，我们就可以重启celery并启用celery的定时任务调度器，现在终端下，运行celery的定时任务程序，以下命令：



```shell
celery -A mycelery.main beat # mycelery.main是celery的主应用文件
```

然后再创建一个终端，运行以下命令，上面的命令必须先指定：



```shell
celery -A mycelery.main worker --loglevel=info
```

注意，使用的时候如果有时区必须先配置好系统时区

要完成订单的任务功能，如果需要调用django框架的模型操作，那么必须针对django框架进行配置加载和初始化。main.py文件



```python
import os
from celery import Celery
# 1.创建实例对象
app = Celery('luffy')
# 2.把celery和django进行组合,识别和加载django的配置文件
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'luffyapi.settings.dev')
# 3.在当前celery中启动django框架，对django框架进行进行初始化
import django
django.setup()
# 4.加载配置
app.config_from_object('celery_tasks.config')
# 5.注册任务[自动搜索并加载任务]
# 参数必须必须是一个列表,里面的每一个任务都是任务的路径名称
# app.autodiscover_tasks(['任务1','任务2'])
app.autodiscover_tasks(['celery_tasks.sms','celery_tasks.order'])
# 6.在终端下面运行celery命令启动celery
# celery -A 主程序 worker --loglevel=info
# celery -A celery_tasks.main worker --loglevel=info
```

